<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tantk land</title>
    <link>/</link>
    <description>Recent content on tantk land</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>euc-kr</language>
    <managingEditor>tantk90@hotmail.com (tantk)</managingEditor>
    <webMaster>tantk90@hotmail.com (tantk)</webMaster>
    <lastBuildDate>Tue, 20 Sep 2016 01:23:50 +0900</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>배열 뒤집기</title>
      <link>/posts/reverse-array/</link>
      <pubDate>Tue, 20 Sep 2016 01:23:50 +0900</pubDate>
      <author>tantk90@hotmail.com (tantk)</author>
      <guid>/posts/reverse-array/</guid>
      <description>

&lt;h1 id=&#34;문제:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;문제&lt;/h1&gt;

&lt;p&gt;배열 안의 데이터 순서를 역순으로 바꾼다고 하자.&lt;br /&gt;
&lt;code&gt;[&#39;a&#39;, &#39;b,&#39; &#39;c&#39;, &#39;d&#39;]&lt;/code&gt;와 같은 배열을 &lt;code&gt;[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;]&lt;/code&gt;와 같이 뒤집고 싶다는 것이다.&lt;br /&gt;
C#, Python과 같이 사용자 친화적 언어들은 &lt;code&gt;.reverse()&lt;/code&gt;하면 아주 손쉽게 배열을 뒤집을 수 있지만, C와 같은 언어에서는 한 번쯤 생각해 볼 수 있는 문제이다.&lt;/p&gt;

&lt;h2 id=&#34;새로운-배열에-역순으로-복사:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;새로운 배열에 역순으로 복사&lt;/h2&gt;

&lt;p&gt;아마도 가장 단순 무식하게 떠올릴 수 있는 방법은, 똑같은 크기의 배열을 새로 만들어서 역순으로 데이터를 옮기는 것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char new_array[SIZE];
for(i = 0; i &amp;lt; SIZE; ++i) {
    new_array[SIZE - 1 - i] = old_array[i];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;간단히 옮기는 것 까지는 좋았는데, 배열 크기 만큼의 새로운 메모리가 필요하다니 낭비가 너무 심하다. 게다가 원본 저장소 &lt;code&gt;old_array&lt;/code&gt;를 그대로 사용하고 싶다면 &lt;code&gt;memcpy&lt;/code&gt;를 추가로 수행해줘야 한다.&lt;/p&gt;

&lt;p&gt;뭐, 위 방법을 쓸리는 없고, 그냥 한 번 생각해보자는 것이니까 다음을 보자.&lt;/p&gt;

&lt;h2 id=&#34;데이터-스왑을-이용:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;데이터 스왑을 이용&lt;/h2&gt;

&lt;p&gt;일반적으로 사용되는 가장 흔한 형태는, 아래와 같이 데이터 스왑을 이용해서 배열을 뒤집는 방법일 것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char temp;
for(i = 0; i &amp;lt; SIZE / 2; ++i) {
    temp = array[i];
    array[i] = array[SIZE - 1 - i];
    array[SIZE - 1 - i] = temp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;배열의 양 끝에서부터 중간 지점까지 각각 차례로 한 칸씩 이동하며 데이터를 교환함으로써 배열의 순서를 뒤집고 있다. 데이터 스왑에는 임시 메모리를 이용한 전형적인 방법이 사용되었다.&lt;br /&gt;
이 정도면 아주 작은 추가 메모리로 원본 저장소도 유지할 수 있고, 연산횟수도 반으로 줄었으니 더할 나위 없어 보인다.&lt;/p&gt;

&lt;p&gt;그러나 모종의 변태들은, 새하얀 도화지의 까만 점 처럼 &lt;code&gt;temp&lt;/code&gt;가 자꾸 눈에 밟히고 치명적인 오점인 것처럼 생각할지도 모른다.&lt;/p&gt;

&lt;h1 id=&#34;배타적-논리합-xor-을-이용한-데이터-스왑:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;배타적 논리합(XOR)을 이용한 데이터 스왑&lt;/h1&gt;

&lt;p&gt;비트 연산 XOR을 이용하면 여분의 메모리를 사용하지 않고도 데이터를 교환할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char a = &#39;a&#39;, b = &#39;b&#39;;
a ^= b;
b ^= a;
a ^= b;
// DONE. a == &#39;b&#39;, b == &#39;a&#39;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;정말 간단하지 않은가? 한 번 &lt;a href=&#34;http://cpp.sh&#34;&gt;직접 실험&lt;/a&gt; 해보기 바란다.&lt;/p&gt;

&lt;p&gt;어떻게 이게 가능한걸까? 이는 배타적 논리합이 갖는, 두 피연산자의 서로 다른 성질만을 남긴다는 점을 교묘하게 이용하고 있기 때문이다.&lt;br /&gt;
&lt;code&gt;a&lt;/code&gt;가 a와 b의 공통 성질, a만 가지는 성질의 두 가지로 이루어져 있고, &lt;code&gt;b&lt;/code&gt;는 a와 b의 공통 성질, b만 가지는 성질의 두 가지로 이루어져 있다고 생각하고 위의 코드에 대입해보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;char a = (ab 공통의 성질, a의 유일한 성질), b = (ab 공통의 성질, b의 유일한 성질);
a = (ab 공통, a의 유일) ^ (ab 공통, b의 유일); // -&amp;gt; (a의 유일, b의 유일)
b = (ab 공통, b의 유일) ^ (a의 유일, b의 유일); // -&amp;gt; (ab 공통, a의 유일) == &#39;a&#39;
a = (a의 유일, b의 유일) ^ (ab 공통, a의 유일); // -&amp;gt; (ab 공통, b의 유일) == &#39;b&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;아주 훌륭하게 데이터가 스왑 되었다.&lt;/p&gt;

&lt;p&gt;벤 다이어그램으로 보면, 더 쉽게 이해할 수 있다.
&lt;img src=&#34;venn_diagram.png&#34; alt=&#34;데이터 교환 과정&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;다른-자료형에의-적용:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;다른 자료형에의 적용&lt;/h2&gt;

&lt;p&gt;메모리 내용 자체를 교환하는 방식이니까 어떤 데이터든 교환이 가능할까?&lt;br /&gt;
비트 연산은 정수형 자료형만 가능하므로 일반적으로는 다른 자료형에 적용할 수 없지만, 약간의 트릭으로 실수형 자료형과 같은 다른 자료형에도 적용할 수 있다.&lt;/p&gt;

&lt;p&gt;바로 포인터를 이용하는 것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;float a = 1.0f, b = -1.0f;
*(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;a)) ^= *(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;b));
*(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;b)) ^= *(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;a));
*(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;a)) ^= *(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;b));  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;캐스트 연산자 때문에 뭔가 복잡해 보이지만, float 자료형이 int 자료형인 것처럼 컴파일러를 속였을 뿐이다.&lt;br /&gt;
비록 정수형 자료형의 크기와 동일한 크기를 가진 자료형만 해당되지만, 어엿하게 실수형 자료형에도 적용할 수 있다는 말이다.&lt;/p&gt;

&lt;h2 id=&#34;xor을-이용하면-정말-빠를까:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;XOR을 이용하면 정말 빠를까?&lt;/h2&gt;

&lt;p&gt;그렇다면, XOR을 이용한 방식이 정말 더 좋은지 확인해보자.&lt;/p&gt;

&lt;p&gt;먼저 XOR을 이용한 방법의 어셈블리 코드를 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;; 7    :    *(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;a)) ^= *(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;b));
  00042 8b 45 f4     mov     eax, DWORD PTR _a$[ebp]
  00045 33 45 e8     xor     eax, DWORD PTR _b$[ebp]
  00048 89 45 f4     mov     DWORD PTR _a$[ebp], eax
; 8    :    *(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;b)) ^= *(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;a));
  0004b 8b 45 e8     mov     eax, DWORD PTR _b$[ebp]
  0004e 33 45 f4     xor     eax, DWORD PTR _a$[ebp]
  00051 89 45 e8     mov     DWORD PTR _b$[ebp], eax
; 9    :    *(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;a)) ^= *(reinterpret_cast&amp;lt;int *&amp;gt;(&amp;amp;b));
  00054 8b 45 f4     mov     eax, DWORD PTR _a$[ebp]
  00057 33 45 e8     xor     eax, DWORD PTR _b$[ebp]
  0005a 89 45 f4     mov     DWORD PTR _a$[ebp], eax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음은 임시 메모리를 이용한 방법의 어셈블리 코드이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;; 12   :    temp = a;
  0005d f3 0f 10 45 f4   movss   xmm0, DWORD PTR _a$[ebp]
  00062 f3 0f 11 45 dc   movss   DWORD PTR _temp$[ebp], xmm0
; 13   :    a = b;
  00067 f3 0f 10 45 e8   movss   xmm0, DWORD PTR _b$[ebp]
  0006c f3 0f 11 45 f4   movss   DWORD PTR _a$[ebp], xmm0
; 14   :    b = temp;
  00071 f3 0f 10 45 dc   movss   xmm0, DWORD PTR _temp$[ebp]
  00076 f3 0f 11 45 e8   movss   DWORD PTR _b$[ebp], xmm0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;전자는 후자에 비해 XOR 연산을 위한 CPU 사이클이 하나씩 더 들어가 있다.&lt;br /&gt;
어셈블리 코드를 볼 줄 모른다고 해도, 척 보면 XOR을 이용한 방식의 코드 길이가 3줄 더 많다는 것을 알 수 있다. 이는 CPU의 연산이 세 번 더 수행된다는 뜻이다.&lt;/p&gt;

&lt;p&gt;실제로 얼마나 성능 차가 나는지 실험 결과를 보자.&lt;br /&gt;
아래는 특정 배열에 대해 무작위(&lt;a href=&#34;https://ko.wikipedia.org/wiki/분기_예측&#34;&gt;분기 예측&lt;/a&gt; 방지) 원소 교환을 9999999회 수행한 결과이다. (3.3Ghz CPU)&lt;/p&gt;

&lt;p&gt;&lt;center&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;방법&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;소요 시간&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;XOR&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;42 ms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;임시 메모리&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;15 ms&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;확실히 임시 메모리를 이용한 방법이 더 빠르긴 하지만, 이 정도의 미미한 차이는 무시할 수 있는 수준이다.&lt;/p&gt;

&lt;h1 id=&#34;결론:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;결론&lt;/h1&gt;

&lt;p&gt;어째 의식이 흐르듯 배열 뒤집기에서 데이터 스왑으로 주제가 바뀐 것 같지만&amp;hellip;&lt;/p&gt;

&lt;p&gt;아무튼 결론적으로 얘기하자면, 배열을 뒤집을 땐 데이터 스왑을 이용한 방식으로 구현하는 것이 좋고, 데이터 스왑 방식으로는 임시 메모리를 이용하든 XOR을 이용하든 개발자 마음대로 라는 것이다.&lt;br /&gt;
XOR을 이용한 방식은, 알아두면 &amp;lsquo;이렇게 변태같이 데이터 스왑하는 방법도 있다!&amp;rsquo; 하고 자랑할 수도 있다.&lt;/p&gt;

&lt;p&gt;물론, 영상처리와 같이 10ms가 아쉬운 경우라면 임시 메모리를 이용한 방법이 더 적절하겠지만 말이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>콘솔 프로그램 실행기</title>
      <link>/posts/console-app-launcher/</link>
      <pubDate>Fri, 17 Jun 2016 15:40:57 +0900</pubDate>
      <author>tantk90@hotmail.com (tantk)</author>
      <guid>/posts/console-app-launcher/</guid>
      <description>

&lt;h1 id=&#34;사설:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;사설&lt;/h1&gt;

&lt;p&gt;영상처리 과제를 할 때였다. 알고리즘의 파라미터를 다양하게 변화시켜 그에 따른 여러 결과를 보여야 했다.&lt;br /&gt;
그런데, 윈도우에서 콘솔 프로그램의 파라미터를 계속 바꾸는 것이 여간 귀찮은게 아니었다. 특히 실행이 끝나면 무의식적으로 cmd 창을 끄는 버릇 때문에, 다시 cmd 창을 켜고 실행 파일 위치까지 이동하는 과정이 너무 귀찮았다.&lt;/p&gt;

&lt;p&gt;Batch 파일은 작성하는 방법을 제대로 알지 못했고, 입력 파라미터가 정해진게 아니어서 미리 작업를 예약하는 방식은 쓸 수 없었다.
그렇다고 콘솔 프로그램을 GUI로 새로 작성하기에는 시간이 아깝다.&lt;/p&gt;

&lt;p&gt;결국 C# winform을 이용해, 콘솔 프로그램의 위치를 기억하고 파라미터를 입력할 수 있는 간단한 프로그램을 작성하기로 했다.&lt;/p&gt;

&lt;h1 id=&#34;프로그램-스크린샷:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;프로그램 스크린샷&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;app.png&#34; alt=&#34;프로그램 스크린샷&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;목표:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;목표&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;콘솔 프로그램의 위치와 입력했던 파라미터를 기억한다.&lt;/li&gt;
&lt;li&gt;콘솔 프로그램의 실행 및 파라미터 입력을 GUI 환경에서 수행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;파라미터-입력-및-실행:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;파라미터 입력 및 실행&lt;/h2&gt;

&lt;p&gt;내가 원했던 것은, 콘솔 프로그램에 파라미터를 입력하고 실행하면 그 실행 내용과 결과가 cmd 창에 출력되는 모습이었는데, &lt;code&gt;System.Diagnotics.Process&lt;/code&gt;로 콘솔 프로그램을 직접 실행시켰더니 프로그램 종료와 함께 cmd 창이 닫혔다.&lt;br /&gt;
그래서, cmd부터 실행시키고 cmd에서 콘솔 프로그램을 실행시키는 방향으로 설계해야 했으며, 이는 콘솔 프로그램 및 파라미터가 담긴 명령줄을 cmd의 파라미터로 실행하여 해결했다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true&#34;&gt;cmd의 옵션&lt;/a&gt;을 확인해 보니, cmd에 명령줄을 전달하려면 &lt;code&gt;/c&lt;/code&gt; 또는 &lt;code&gt;/k&lt;/code&gt; 옵션을 이용하면 된다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;/c : Carries out the command specified by string and then stops.&lt;br /&gt;
/k : Carries out the command specified by string and continues.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;둘 중 무슨 옵션을 이용해야 할까? 바로 창이 닫히는게 문제니까 &lt;code&gt;/k&lt;/code&gt; 옵션을 쓰는게 좋을까? 그러나 &lt;code&gt;/k&lt;/code&gt; 옵션을 이용하면 프로그램 종료 후 다음 명령을 기다리는 프롬프트 화면으로 넘어가기 때문에 창을 수작업으로 닫아줘야 한다. 결과 확인만 하면 되는데 귀찮은 작업이 늘어난다.&lt;/p&gt;

&lt;p&gt;결국 &lt;code&gt;/c&lt;/code&gt; 옵션을 이용해야 하는데, &amp;lsquo;계속하려면 아무키나 누르세요&amp;rsquo;를 띄우는게 좋겠다.&lt;br /&gt;
처음 코딩을 배울 때 꼼수로 애용했던 &lt;code&gt;pause&lt;/code&gt;를 이용하자. cmd를 띄우는 명령과 함께 사용해야 하니 &lt;code&gt;&amp;amp;&lt;/code&gt;를 이용하면 된다. (여러 명령을 함께 실행하는 방법은 &lt;a href=&#34;https://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/ntcmds_shelloverview.mspx?mfr=true&#34;&gt;여기&lt;/a&gt;를 참조)&lt;/p&gt;

&lt;p&gt;명령줄은 다음과 같을 것이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;# cmd.exe /c myapp.exe -myparam &amp;amp; pause
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이를 C# Winform에서 실행해 보자.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// using System.Diagnotics;
// appPath: 프로그램 경로. ex) &amp;quot;c:\myapp.exe&amp;quot;
// tb_parameters: 파라미터가 입력된 Textbox.

Process app = new Process();
app.StartInfo.FileName = &amp;quot;cmd.exe&amp;quot;;
app.StartInfo.Arguments = &amp;quot;/C &amp;quot; + appPath + &amp;quot; &amp;quot; + tb_parameters.Text + &amp;quot;&amp;amp; pause&amp;quot;;
app.Start();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이때, &lt;code&gt;Process&lt;/code&gt;의 작업 디렉토리를 설정해주지 않으면 콘솔 프로그램 &lt;strong&gt;실행기의 위치&lt;/strong&gt;가 작업 디렉토리가 되므로, &lt;code&gt;System.IO.Path.GetDirectoryName&lt;/code&gt;으로 콘솔 프로그램의 위치를 가져와 작업 디렉토리로 설정해주자.&lt;/p&gt;

&lt;p&gt;한 줄만 추가해 주면 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// using System.IO;

app.StartInfo.WorkingDirectory = Path.GetDirectoryName(appPath);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;레지스트리-저장:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;레지스트리 저장&lt;/h2&gt;

&lt;p&gt;실행했던 콘솔 프로그램의 위치와 파라미터의 기억은 레지스트리를 이용한다.&lt;/p&gt;

&lt;p&gt;레지스트리의 저장 위치는 &lt;code&gt;LOCAL_MACHINE&lt;/code&gt;과 &lt;code&gt;CURRENT_USER&lt;/code&gt;의 두 가지 선택지가 존재하는데, &lt;code&gt;LOCAL_MACHINE&lt;/code&gt;은 컴퓨터 전역 / 모든 사용자에게 적용되는 필드로 저장할 때 관리자 권한을 요구한다. &lt;code&gt;CURRENT_USER&lt;/code&gt;는 사용자 계정에 종속되는 필드로 프로그램의 환경 설정을 저장할 때 일반적으로 사용된다.&lt;/p&gt;

&lt;p&gt;콘솔 프로그램 실행기는 특별한 정보를 저장하는 것이 아니니 &lt;code&gt;CURRENT_USER&lt;/code&gt; 필드를 이용한다.&lt;br /&gt;
그리고, 일반 소프트웨어는 보통 &lt;code&gt;Software&lt;/code&gt; 필드를 이용하므로 서브 키를 &lt;code&gt;Software\\AppLauncher&lt;/code&gt;로 만들자.&lt;br /&gt;
C# 코드 상에선 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// using Microsoft.Win32;

RegistryKey subkey = Registry.CurrentUser.OpenSubKey(&amp;quot;Software\\AppLauncher&amp;quot;, true);
// 먼저 OpenSubKey로 이미 서브 키가 있는지 확인한다.
// 쓰기를 수행하려면 두 번째 인자로 true를 넘겨줘야 한다.
if (subkey == null)
{
    subkey = Registry.CurrentUser.CreateSubKey(&amp;quot;Software\\AppLauncher&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;레지스트리에 저장할 것은 프로그램의 경로와 파라미터이다. 두 값 모두 &lt;code&gt;string&lt;/code&gt;이므로 &lt;code&gt;RegistryValueKind.String&lt;/code&gt;으로 지정하여 저장한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;subkey.SetValue(&amp;quot;AppPath&amp;quot;, appPath, RegistryValueKind.String);
subkey.SetValue(&amp;quot;Parameters&amp;quot;, tb_parameters.Text, RegistryValueKind.String);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;레지스트리를 가져올 때는, &lt;code&gt;object&lt;/code&gt; 객체를 반환하는 &lt;code&gt;RegistryKey.GetValue&lt;/code&gt;를 이용한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C#&#34;&gt;// using Microsoft.Win32;

RegistryKey subkey = Registry.CurrentUser.OpenSubKey(&amp;quot;Software\\AppLauncher&amp;quot;);
if (subkey != null)
{
    appPath = subkey.GetValue(&amp;quot;AppPath&amp;quot;).ToString();
    tb_parameters.Text = subkey.GetValue(&amp;quot;Parameters&amp;quot;).ToString(); 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;끝:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;끝&lt;/h2&gt;

&lt;p&gt;핵심 기능을 구현하는 법은 알았으니 프로그램 구조를 적절히 설계만 하면 된다.&lt;/p&gt;

&lt;p&gt;콘솔 프로그램을 실행하는 부분은 실행 버튼의 &lt;code&gt;Click&lt;/code&gt; 이벤트에 구현하면 될 것이고&amp;hellip;&lt;br /&gt;
레지스트리를 가져올 때는 &lt;code&gt;Load&lt;/code&gt; 이벤트를, 기록할 때는 &lt;code&gt;Form_Closed&lt;/code&gt;를 이용하자.&lt;/p&gt;

&lt;h1 id=&#34;references:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;References&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.differencebetween.net/technology/hardware-technology/difference-between-hkey_current_user-and-hkey_local_machine/&#34;&gt;http://www.differencebetween.net/technology/hardware-technology/difference-between-hkey_current_user-and-hkey_local_machine/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Search</title>
      <link>/search/</link>
      <pubDate>Wed, 15 Jun 2016 04:50:09 +0900</pubDate>
      <author>tantk90@hotmail.com (tantk)</author>
      <guid>/search/</guid>
      <description></description>
    </item>
    
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Mon, 02 May 2016 02:06:32 +0900</pubDate>
      <author>tantk90@hotmail.com (tantk)</author>
      <guid>/about/</guid>
      <description>

&lt;h1 id=&#34;tantk-땅꾸:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;tantk == 땅꾸&lt;/h1&gt;

&lt;p&gt;A game developer wannabe.&lt;/p&gt;

&lt;h2 id=&#34;feel-free-to-contact:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Feel free to contact&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;i class=&#34;fa fa-envelope&#34;&gt;&lt;/i&gt; &lt;a href=&#34;mailto:tantk90@hotmail.com&#34;&gt;tantk90 at hotmail.com&lt;/a&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=&#34;fa fa-github&#34;&gt;&lt;/i&gt; &lt;a href=&#34;https://github.com/o-tantk&#34;&gt;o-tantk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;i class=&#34;fa fa-stack-overflow&#34;&gt;&lt;/i&gt; &lt;a href=&#34;http://stackoverflow.com/users/1435673/hyunan-kwon&#34;&gt;Stack overflow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;skills:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;SKILLS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Languages: C++(Primary), C, C#, GLSL, CUDA, &amp;hellip;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Frameworks: STL, OpenGL, Unity3D, &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>땅꾸의 블로그</title>
      <link>/posts/hello-world/</link>
      <pubDate>Mon, 02 May 2016 02:06:23 +0900</pubDate>
      <author>tantk90@hotmail.com (tantk)</author>
      <guid>/posts/hello-world/</guid>
      <description>

&lt;h1 id=&#34;안녕하세요-땅꾸입니다:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;안녕하세요. 땅꾸입니다.&lt;/h1&gt;

&lt;p&gt;이 블로그는 &lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;라는 Static Website Engine을 이용해서 만들었고, &lt;a href=&#34;https://github.com/&#34;&gt;Github&lt;/a&gt;를 이용해 호스팅 하고 있습니다.&lt;/p&gt;

&lt;h1 id=&#34;이-아래는-markdown-문서의-테스트이므로-무시하셔도-좋습니다:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;이 아래는 markdown 문서의 테스트이므로 무시하셔도 좋습니다.&lt;/h1&gt;

&lt;p&gt;Windows OS의 경로 최대길이는 &lt;code&gt;MAX_PATH&lt;/code&gt;라는 상수값 260으로 제한되어 있다.&lt;/p&gt;

&lt;p&gt;{{//&amp;lt; tweet 742203311508443136 &amp;gt;}}&lt;/p&gt;

&lt;p&gt;다음은 c++ 코드 샘플&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
int main(int argc, char **argv){
    std::cout &amp;lt;&amp;lt; &amp;quot;hello world!&amp;quot; &amp;lt;&amp;lt; std::endl;
    return 0;
}
// 코드는 어디까지 길어질까아ㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏㅏ 는 highlight.js는 자동 줄넘김이다.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다음은 glsl 코드 샘플&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-glsl&#34;&gt;layout(location=0) in vec3 position;

void main(void){
    gl_Position = position;
}
&lt;/code&gt;&lt;/pre&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/KXSUEU7ISfQ&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;p&gt;
&lt;figure &gt;
    
        &lt;img src=&#34;%ed%98%b8%eb%ac%b4%ed%98%b8%eb%ac%b4.jpg&#34; alt=&#34;호무호무&#34; /&gt;
    
    
    &lt;figcaption&gt;
        호무호무한 호무라짱
        
    &lt;/figcaption&gt;
    
&lt;/figure&gt;


위의 호무호무한 호무라짱을 보라! 너무나도 호무호무하다. 호무호무&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;호무호무는 너무나도 호무호무하기에 인용까지 해야 할 정도이다.&lt;br /&gt;
두 번째 인용 줄&lt;/p&gt;

&lt;p&gt;세 번째 인용 줄&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;인용문 끝.&lt;/p&gt;

&lt;h3 id=&#34;shibe-doge:d680e8a854a7cbad6d490c445cba2eba&#34;&gt;Shibe doge&lt;/h3&gt;

&lt;p&gt;본 김에 시베도 보자
&lt;img src=&#34;시베.jpg&#34; alt=&#34;shibe doge&#34; /&gt;
such wow&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>